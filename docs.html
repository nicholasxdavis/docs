<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orbit Loader Final</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #161618;
      color: #fcfcfc;
      font-family: 'Inter', sans-serif;
    }
    .glassmorphism {
      background: rgba(22, 22, 24, 0.7);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(36, 38, 40, 0.5);
      border-radius: 1rem;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-6">

  <div class="glassmorphism w-[260px] h-[260px] flex items-center justify-center p-6">
    <canvas id="planet-loader" class="rounded-lg" style="width: 100%; height: 100%; display: block;"></canvas>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });

    const canvasContainer = document.getElementById('planet-loader').parentElement;
    const width = canvasContainer.clientWidth;
    const height = canvasContainer.clientHeight;

    renderer.setSize(width, height);
    const oldCanvas = document.getElementById('planet-loader');
    oldCanvas.replaceWith(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // Planet
    const planetGeometry = new THREE.SphereGeometry(1, 64, 64);
    const planetMaterial = new THREE.ShaderMaterial({
      uniforms: {
        color: { value: new THREE.Color('#50b1f7') }
      },
      vertexShader: `
        varying vec3 vPosition;
        void main() {
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader: `
        varying vec3 vPosition;
        uniform vec3 color;
        void main() {
          float fade = smoothstep(0.0, 1.0, vPosition.y * 0.5 + 0.5);
          float opacity = 1.0 - fade;
          gl_FragColor = vec4(color, opacity * 0.8);
        }
      `,
      transparent: true,
      depthWrite: true,
      depthTest: true
    });

    const planet = new THREE.Mesh(planetGeometry, planetMaterial);
    planet.castShadow = true;
    planet.receiveShadow = true;
    scene.add(planet);

    // Ring with #161618
    const ringGeometry = new THREE.TorusGeometry(1.5, 0.05, 32, 100);
    const ringMaterial = new THREE.MeshStandardMaterial({
      color: '#999',
      metalness: 0.7,
      roughness: 0.3,
      transparent: true,
      opacity: 0.4
    });

    const ring = new THREE.Mesh(ringGeometry, ringMaterial);

    const ringHolder = new THREE.Object3D();
    ringHolder.rotation.x = Math.PI / 2.1;
    ringHolder.rotation.z = Math.PI / 8;
    ringHolder.position.y = 0;
    scene.add(ringHolder);
    ringHolder.add(ring);

    // Moon orbiting
    const moonGeometry = new THREE.SphereGeometry(0.15, 32, 32);
    const moonMaterial = new THREE.MeshStandardMaterial({
      color: '#06b2fc',
      emissive: '#06b2fc',
      emissiveIntensity: 0.7,
      depthWrite: true,
      depthTest: true
    });

    const moon = new THREE.Mesh(moonGeometry, moonMaterial);

    const pivot = new THREE.Object3D();
    ring.add(pivot);
    pivot.add(moon);
    moon.position.x = 1.5;

    // Correct render order to ensure occlusion
    planet.renderOrder = 1;
    moon.renderOrder = 2;

    renderer.shadowMap.enabled = true;

    function animate() {
      requestAnimationFrame(animate);
      ring.rotation.z += 0.01;
      pivot.rotation.z += 0.05;
      planet.rotation.y += 0.003;
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      const w = canvasContainer.clientWidth;
      const h = canvasContainer.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
